//
// Created by lqs on 2022/9/8.
//

/*
 * TODO 顺序表和链表相关总结
 *  一、逻辑结构
 *      都属于线性表，都是线性结构
 *  二、物理结构（存储结构）
 *      顺序表：
 *          存储结构：
 *              顺序存储结构
 *          优点；
 *              支持随机存取、存储密度高
 *          缺点：
 *              大片连续空间分配不方便，改变容量不方便
 *      链表：
 *          存储结构：
 *              链式存储结构
 *          优点：
 *              离散的小空间分配方便，改变容量方便
 *          缺点：
 *              a、不可随机存取，存储密度低
 *              b、容量虽然可以改变，但是需要移动大量元素，时间成本高
 *  三、数据运算（基本操作）
 *      1、表的创建：
 *          顺序表创建：
 *              需要预分配大片连续空间。若分配空间过小，则之后不方便扩展容量，若预分配的空间过大，则浪费内存资源
 *          链表创建：
 *              只需要分配一个头结点（也可以不要头结点，只声明一个头指针），之后方便扩展
 *      2、表的销毁：
 *          顺序表：
 *              a、修改Length=0
 *              b、系统会自动回收空间
 *          链表：
 *              a、需要手动进行free操作
 *              b、需要一次删除各个节点，即依次手动进行free操作
 *              c、malloc和free必须是成对的出现
 *      3、表的增加和删除
 *          顺序表：
 *              a、增加/删除元素都要将后续的元素后移或者前移
 *              b、时间复杂度为O(n),时间的开销主要来自移动元素
 *                  注意：当数据元素很大时，则移动的时间代价很高
 *          链表：
 *              a、增加/删除元素只需要修改指针即可
 *              b、时间复杂度为O(n),时间的主要开销来自查找目标元素，但是查找元素的时间相对顺序表查找的代价更低
 *      4、表的查找
 *          顺序表：
 *              按位查找，时间复杂度为O(1)
 *              按值查找，时间复杂度为O(n),若表内的元素是有序的，则可以在O(log2^n)时间内找到
 *          链表：
 *              按位查找和按值查找的时间复杂度都是一样为O(n)
 *  四、用顺序表还是链表
 *      1、对弹性(可扩容)要求高选择链表；
 *      2、对增、删的需求较高选择链表；
 *      3、对查的需求较高，选择顺序表。
 *  五、开放式问题的答题思路
 *      问题：
 *          请描述顺序表和链表的......实现线性表时，用顺序表还是链表好？
 *      答题思路：
 *          虽然顺序表和链表的逻辑结构都是线性结构，都属于线性表。
 *          但是二者的存储结构不同，顺序表采用顺序存储结构，为此其支持随机存取，且存储密度高，但是在大片连续空间
 *          的分配上不方便，改变容量也不方便；链表采用链式存储结构，其优点是离散的小空间分配方便，改变容量方便，
 *          缺点是不可以随机存取，存储密度低，其次是容量虽然可以改变，但是需要移动大量的元素，时间成本很高；
 *          由于采用不同的存储方式实现，因此基本操作实现效率也不同。当初始时，顺序表需要一次性预分配大片连续空间，
 *          若分配的空间过小，则之后方便扩容，分配过大，又浪费存储空间，而链表初始化时只需要分配一个头结点，也可以
 *          不要头结点，只声明一个头指针，之后的扩容也很方便；当插入或者删除一个数据元素时，顺序表需要将后续的元素
 *          后移或者前移，其时间复杂度为O(n)，而链表只需要修改指针即可，其时间复杂度为O(n)；当查找一个元素时，顺序表
 *          按位查找的时间复杂度仅为O(1)，但是按值查找时，时间复杂度为O(n)，如果表内的元素时有序的，则可以在O(log2^n)
 *          时间内找到指定的元素，而链表按位查找和按值查找的时间复杂度都一样为O(n)；当删除表时，顺序表只需要修改length为0
 *          系统会自动回收空间，而链表需要手动进行每个节点的free操作，且malloc和free必须是成对的出现。因此对弹性(可扩容)
 *          要求较高时选择链表；对增、删需求较高时选择链表；对查的需求较高时选择顺序表。
 *  六、线性表内容梳理：
 *      数据结构三要素：
 *          a、逻辑结构
 *          b、操作
 *      1、线性表(Linear List)的定义：
 *          线性表是具有相同(每个数据元素所占空间一样大)数据类型n(n>=0)个数据元素的有限序列，其中n为表长，当n=0时线性表是
 *          一个空表。若用L命名线性表，则其一般表示为：
 *              L=(a1,a2,...,ai,ai+1,...,an)
 *              概念解析：
 *                  a、ai是线性表中的“第i个”元素线性表中的位序
 *                      注意：位序从1开始，数组下标是从0开始
 *                  b、a1是表头元素；an是表尾元素
 *                  c、除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继
 *      2、线性表的基本操作
 *          2.1、为什么要实现对数据结构的基本操作？
 *              a、团队合作编程，你定义的数据结构要让别人能够很方便的使用（封装）
 *              b、将常用的操作/运算封装成函数，避免重复的工作，降低出错的风险
 *          2.2、基本操作相关函数与说明
 *              a、InitList(&L)：初始化表，构造一个空的线性表L，分配内存空间；
 *              b、DestroyList(&L)；销毁操作。销毁线性表，并释放线性表L所占用的内存空间；
 *              c、ListInsert(&L,index,value):插入操作，在表L中的第i哥位置上插入指定元素e；
 *              d、ListDelete(&L,index,&value)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值；
 *              e、LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素；
 *              f、GetElem(L,index)：按位查找操作。获取表L中第i个位置的元素的值
 *          2.3、其他常用操作
 *              a、Length(L)；求表的长度，返回线性表L的长度，即L中数据元素的个数；
 *              b、PrintList(L)；输出操作。按前后顺序输出线性表L的所有元素值；
 *              c、Empty(L)；判空操作。若L为空，则返回true，否则返回false
 *      3、记忆理解小窍门
 *          a、对数据的操作（记忆思路）：创销、增删改查；
 *          b、C语言函数的定义：<返回值类型> 函数名 (<参数1类型> 参数1,<参数2类型> 参数2, .....)
 *          c、实际开发中，可根据实际需求定义其他的基本操作
 *          d、函数名和参数的形式、命名都可改变(参考：严蔚敏版《数据结构》，注意：命名要有可读性)
 *          e、什么时候要传入引用“&”：对参数的修改结果需要“带回来”
 */